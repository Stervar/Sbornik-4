{"version":3,"file":"py-terminal-BMEpK70u.js","sources":["../src/plugins/py-terminal.js"],"sourcesContent":["// PyScript py-terminal plugin\nimport { TYPES, hooks } from \"../core.js\";\nimport { notify } from \"./error.js\";\nimport { defineProperty } from \"polyscript/exports\";\n\nconst SELECTOR = [...TYPES.keys()]\n    .map((type) => `script[type=\"${type}\"][terminal],${type}-script[terminal]`)\n    .join(\",\");\n\n// show the error on main and\n// stops the module from keep executing\nconst notifyAndThrow = (message) => {\n    notify(message);\n    throw new Error(message);\n};\n\nconst notParsedYet = (script) => !bootstrapped.has(script);\n\nconst onceOnMain = ({ attributes: { worker } }) => !worker;\n\nconst bootstrapped = new WeakSet();\n\nlet addStyle = true;\n\n// this callback will be serialized as string and it never needs\n// to be invoked multiple times. Each xworker here is bootstrapped\n// only once thanks to the `sync.is_pyterminal()` check.\nconst workerReady = ({ interpreter, io, run }, { sync }) => {\n    if (!sync.is_pyterminal()) return;\n\n    // in workers it's always safe to grab the polyscript currentScript\n    run(\"from polyscript.currentScript import terminal as __terminal__\");\n\n    // This part is inevitably duplicated as external scope\n    // can't be reached by workers out of the box.\n    // The detail is that here we use sync though, not readline.\n    const decoder = new TextDecoder();\n    let data = \"\";\n    const generic = {\n        isatty: true,\n        write(buffer) {\n            data = decoder.decode(buffer);\n            sync.pyterminal_write(data);\n            return buffer.length;\n        },\n    };\n    interpreter.setStdout(generic);\n    interpreter.setStderr(generic);\n    interpreter.setStdin({\n        isatty: true,\n        stdin: () => sync.pyterminal_read(data),\n    });\n\n    io.stderr = (error) => {\n        sync.pyterminal_write(`${error.message || error}\\n`);\n    };\n};\n\nconst pyTerminal = async () => {\n    const terminals = document.querySelectorAll(SELECTOR);\n\n    const unknown = [].filter.call(terminals, notParsedYet);\n\n    // no results will look further for runtime nodes\n    if (!unknown.length) return;\n    // early flag elements as known to avoid concurrent\n    // MutationObserver invokes of this async handler\n    else unknown.forEach(bootstrapped.add, bootstrapped);\n\n    // we currently support only one terminal as in \"classic\"\n    if ([].filter.call(terminals, onceOnMain).length > 1)\n        notifyAndThrow(\"You can use at most 1 main terminal\");\n\n    // import styles lazily\n    if (addStyle) {\n        addStyle = false;\n        document.head.append(\n            Object.assign(document.createElement(\"link\"), {\n                rel: \"stylesheet\",\n                href: new URL(\"./xterm.css\", import.meta.url),\n            }),\n        );\n    }\n\n    // lazy load these only when a valid terminal is found\n    const [{ Terminal }, { Readline }, { FitAddon }] = await Promise.all([\n        import(/* webpackIgnore: true */ \"../3rd-party/xterm.js\"),\n        import(/* webpackIgnore: true */ \"../3rd-party/xterm-readline.js\"),\n        import(/* webpackIgnore: true */ \"../3rd-party/xterm_addon-fit.js\"),\n    ]);\n\n    for (const element of unknown) {\n        // hopefully to be removed in the near future!\n        if (element.matches('script[type=\"mpy\"],mpy-script'))\n            notifyAndThrow(\"Unsupported terminal.\");\n\n        const readline = new Readline();\n\n        // common main thread initialization for both worker\n        // or main case, bootstrapping the terminal on its target\n        const init = (options) => {\n            let target = element;\n            const selector = element.getAttribute(\"target\");\n            if (selector) {\n                target =\n                    document.getElementById(selector) ||\n                    document.querySelector(selector);\n                if (!target) throw new Error(`Unknown target ${selector}`);\n            } else {\n                target = document.createElement(\"py-terminal\");\n                target.style.display = \"block\";\n                element.after(target);\n            }\n            const terminal = new Terminal({\n                theme: {\n                    background: \"#191A19\",\n                    foreground: \"#F5F2E7\",\n                },\n                ...options,\n            });\n            const fitAddon = new FitAddon();\n            terminal.loadAddon(fitAddon);\n            terminal.loadAddon(readline);\n            terminal.open(target);\n            fitAddon.fit();\n            terminal.focus();\n            defineProperty(element, \"terminal\", { value: terminal });\n            return terminal;\n        };\n\n        // branch logic for the worker\n        if (element.hasAttribute(\"worker\")) {\n            // add a hook on the main thread to setup all sync helpers\n            // also bootstrapping the XTerm target on main *BUT* ...\n            hooks.main.onWorker.add(function worker(_, xworker) {\n                // ... as multiple workers will add multiple callbacks\n                // be sure no xworker is ever initialized twice!\n                if (bootstrapped.has(xworker)) return;\n                bootstrapped.add(xworker);\n\n                // still cleanup this callback for future scripts/workers\n                hooks.main.onWorker.delete(worker);\n\n                init({\n                    disableStdin: false,\n                    cursorBlink: true,\n                    cursorStyle: \"block\",\n                });\n\n                xworker.sync.is_pyterminal = () => true;\n                xworker.sync.pyterminal_read = readline.read.bind(readline);\n                xworker.sync.pyterminal_write = readline.write.bind(readline);\n            });\n\n            // setup remote thread JS/Python code for whenever the\n            // worker is ready to become a terminal\n            hooks.worker.onReady.add(workerReady);\n        } else {\n            // in the main case, just bootstrap XTerm without\n            // allowing any input as that's not possible / awkward\n            hooks.main.onReady.add(function main({ interpreter, io, run }) {\n                console.warn(\"py-terminal is read only on main thread\");\n                hooks.main.onReady.delete(main);\n\n                // on main, it's easy to trash and clean the current terminal\n                globalThis.__py_terminal__ = init({\n                    disableStdin: true,\n                    cursorBlink: false,\n                    cursorStyle: \"underline\",\n                });\n                run(\"from js import __py_terminal__ as __terminal__\");\n                delete globalThis.__py_terminal__;\n\n                // This part is inevitably duplicated as external scope\n                // can't be reached by workers out of the box.\n                // The detail is that here we use readline here, not sync.\n                const decoder = new TextDecoder();\n                let data = \"\";\n                const generic = {\n                    isatty: true,\n                    write(buffer) {\n                        data = decoder.decode(buffer);\n                        readline.write(data);\n                        return buffer.length;\n                    },\n                };\n                interpreter.setStdout(generic);\n                interpreter.setStderr(generic);\n                interpreter.setStdin({\n                    isatty: true,\n                    stdin: () => readline.read(data),\n                });\n\n                io.stderr = (error) => {\n                    readline.write(`${error.message || error}\\n`);\n                };\n            });\n        }\n    }\n};\n\nconst mo = new MutationObserver(pyTerminal);\nmo.observe(document, { childList: true, subtree: true });\n\n// try to check the current document ASAP\nexport default pyTerminal();\n"],"names":["SELECTOR","TYPES","keys","map","type","join","notifyAndThrow","message","notify","Error","notParsedYet","script","bootstrapped","has","onceOnMain","attributes","worker","WeakSet","addStyle","workerReady","interpreter","io","run","sync","is_pyterminal","decoder","TextDecoder","data","generic","isatty","write","buffer","decode","pyterminal_write","length","setStdout","setStderr","setStdin","stdin","pyterminal_read","stderr","error","pyTerminal","async","terminals","document","querySelectorAll","unknown","filter","call","forEach","add","head","append","Object","assign","createElement","rel","href","URL","url","Terminal","Readline","FitAddon","Promise","all","import","element","matches","readline","init","options","target","selector","getAttribute","getElementById","querySelector","style","display","after","terminal","theme","background","foreground","fitAddon","loadAddon","open","fit","focus","defineProperty","value","hasAttribute","hooks","main","onWorker","_","xworker","delete","disableStdin","cursorBlink","cursorStyle","read","bind","onReady","console","warn","globalThis","__py_terminal__","MutationObserver","observe","childList","subtree","pyTerminal$1"],"mappings":"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"}